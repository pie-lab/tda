---
title: "Item Difficulty"
date: "Last updated `r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
    code_folding: hide
---

To cite these data:
[add data paper reference here]

This page lists information from each of the two forms used to derive the [average proportion correct](https://pie-lab.github.io/tda/tda-difficulty.html) for each of the 2,818 unique trait descriptive adjectives. See the [top of this page](https://pie-lab.github.io/tda/tda-difficulty.html) for further explanation of the two different forms.

Specifically, the table below contains the item label (e.g., "q_2XXXX"), the trait descriptive adjective (e.g., "stern"), the total number of respondents for the item (N), the proportion of respondents who correctly matched the term with its definition (e.g., .92), the distractor index value (see below), and the form corresponding with these statistics (A or B). Again, each adjective was administered in two different forms (A and B), with different alternative response options across the two forms. The alternative response options were generated randomly from the full pool of adjectives (i.e., the remaining 2,817 options).

Note that we have intentionally omitted the definitions and distractor response options corresponding to each item label. This was done to protect the validity of the items for subsequent use. Contact the lead author for access to this information.

The mean proportion correct for each adjective across both forms can be found [here](https://pie-lab.github.io/tda/tda-difficulty.html).

The data can be downloaded [here](https://doi.org/10.7910/DVN/5T80PF).

Please consult the reference listed above for more information about this project.

```{r, include = F}
knitr::opts_chunk$set(echo = T, message = F, warning = F)
```

```{r}
library(here) # for engaging with working environment
library(tidyverse) # for data cleaning and manipulation
library(Hmisc) # for weighted means
library(DT) # for viewing data tables

data = read_csv(here("data/TDA_data_scored.csv"))
masterKey = read_csv(here("data/masterkey.csv"))

data = data %>%
  filter(included == "Yes") %>% # remove participants screened out for demographic and quality reasons
  select(starts_with("q_")) # select only TDA items

data_means = colMeans(data, na.rm = T) #calculate column means

all_item_means = data.frame( # create data frame with...
  item = names(data_means), # ...variable name and...
  prop_correct = data_means #... proportion correct
)

item_prop = masterKey %>% # join the masterKey (item name, correct answer, and form)
  full_join(all_item_means) %>% # with proportion correct
  mutate(prop_correct = round(prop_correct, 2)) # round to 2 decimal places

# next we count the number of administrations of each item
item_prop$N = colSums(!is.na(data)) # count non-missing

# now we calculate the distractor index

data_re = read_csv(here("data/TDA_data_recoded.csv")) # use recoded dataset

data_re = filter(data_re, included == "Yes") # remove participants screend out for demographic and quality reasons

distract = data_re %>%
  select(starts_with("q_")) %>% #select only TDA items
  gather("item", "response") %>% # stack all columns: creates 2 column data frame
  mutate(response = ifelse(response == "Ans", #if response is correct
                           NA,  #make missing
                           response)) %>% #else keep as is
  filter(!is.na(response)) %>% # remove missing responses (including correct responses)
  full_join(masterKey) # join with masterKey

  
distract = distract %>%
  group_by(item, response) %>% # for each unique response for each item
  count() %>% # count
  group_by(item) %>% # for each item
  mutate(wrong_n = sum(n), # how many counts (this is only incorrect responses)
         prop_wrong = n/wrong_n) %>% # what proportion of wrong is each response
  filter(str_detect(response, "^R")) %>% #select only distractors
  summarise(prop_wrong = max(prop_wrong), #what's max proportion
            n_wrong = max(wrong_n)) #how many wrong

item_prop = item_prop %>%
  full_join(distract) # add to item proportion table

item_prop = item_prop %>%
  mutate(across(where(is.double), round, 2)) #round all numbers to 2 decimal places
```

```{r, results = 'asis'}
item_prop %>%
 mutate(form = case_when(
   form == "C" ~ "A", # change these forms (C and D were fixes to poor or incorrect items)
   form == "D" ~ "B",
   TRUE ~ form
 )) %>%
  select(item, adjective, N, prop_correct, prop_wrong, form) %>% #just show these columns
  DT::datatable( #make interactive html table
    colnames = c("Item", "Adjective", "N", "Proportion Correct", "Distractor Index", "Form"), #col names
    filter = "top", # can filter
    rownames = F #don't need
  )
```

```{r}
item_prop %>%
  select(item, adjective, N, prop_correct, prop_wrong, form) %>%
  rename(distractor = prop_wrong) %>%
  write_csv(file = here("data/item_difficulty.csv"))
```

