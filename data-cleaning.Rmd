---
title: "Cleaning and summarizing"
date: "Last updated `r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
---

```{r, include = F}
knitr::opts_chunk$set(message = F, warning = F)
```


# Load data and packages

```{r, message = F, warning = F}
library(here) # for engaging with working environment
library(rio) # for importing excel files
library(tidyverse) # for data cleaning and manipulation
library(psych) # for scoring multiple choice items
library(R.utils) # just for the insert() function
```

## Qualtrics survey responses

The excel files contain raw data exported from Qualtrics. The first row of this file contains variable names, but rows 2 and 3 contain meta data. To account, we first load in all data as a "names" data frame and then data starting at row 4, for the raw data. 

```{r, message = F, warning = F}
# read in form A (Prolific)
formA_names = read_csv(
  here("data/Form+A_Prolific_April+2,+2021_15.27.csv"))

formA = read_csv(
  here("data/Form+A_Prolific_April+2,+2021_15.27.csv"), 
  col_names = F, skip = 3)

names(formA) = names(formA_names)
rm(formA_names)

# read in form A (MTurk)
formA_names = read_csv(
  here("data/Form A_April 2, 2021_15.41.numeric.csv"))

formA2 = read_csv(
  here("data/Form A_April 2, 2021_15.41.numeric.csv"), 
  col_names = F, skip = 3)

names(formA2) = names(formA_names)
rm(formA_names)

formA = full_join(formA, formA2)
rm(formA2)

# read in form B (Prolific)
formB_names = read_csv(
  here("data/Form+B_Prolific_April+2,+2021_15.27.csv"))

formB = read_csv(
  here("data/Form+B_Prolific_April+2,+2021_15.27.csv"), 
  col_names = F, skip = 3)

names(formB) = names(formB_names)
rm(formB_names)


# read in form B (MTurk)
formB_names = read_csv(
  here("data/Form B_April 2, 2021_15.44.numeric.csv"))

formB2 = read_csv(
  here("data/Form B_April 2, 2021_15.44.numeric.csv"), 
  col_names = F, skip = 3)

names(formB2) = names(formB_names)
rm(formB_names)

formB = full_join(formB, formB2)
rm(formB2)

# read in form C (Prolific)
formC_names = read_csv(
  here("data/Form+C_April+16,+2021_17.21.csv"))

formC = read_csv(
  here("data/Form+C_April+16,+2021_17.21.csv"), 
  col_names = F, skip = 3)

names(formC) = names(formC_names)
rm(formC_names)
```

In forms A and B, variable names composed solely of numbers (e.g., 20001) refer to the specific variable number as included in the dictionary. These must be prefaced by `q_` for readability. 

```{r}
names(formA) = str_replace(names(formA), # look in this vector of strings
                           "(^)([0-9]*$)", #match two parts. part 1: beginning of string, second part: digits 0 or more times and then the string ends
                           "q_\\2") # replace with q_ followed by the second part of the match

names(formB) = str_replace(names(formB), 
                           "(^)([0-9]*$)", 
                           "q_\\2") 

names(formC) = str_replace(names(formC), 
                           "^Q", 
                           "q_") 

# an additional error in form C -- some variable names were coded with only the last 4 digits (i.e., missing the first "2")
names(formC) = str_replace(names(formC), 
                           "(q_)(\\d{4}$)", "\\12\\2")
```

Remove participants without valid Prolific or MTurk IDs.

```{r}
formA = formA %>%
  filter(!is.na(mTurkCode) | str_length(PROLIFIC_PID) > 3)
formB = formB %>%
  filter(!is.na(mTurkCode) | str_length(PROLIFIC_PID) > 3)
formC = formC %>%
  filter(str_length(PROLIFIC_PID) > 3)
```

## Scoring keys

```{r, message = F, warning = F}
keyA = read_csv(here("keys/key_A.csv"))
keyB = read_csv(here("keys/key_B.csv"))
keyC = import(here("keys/key_C.xlsx"), sheet = 1)
```

Variable names composed solely of numbers (e.g., 1) refer to the response choice number as presented to participants. These must be prefaced by `R_` for readability. 

```{r}
names(keyA) = str_replace(names(keyA), 
                           "(^)([0-9]{1}$)", 
                           "R_\\2") 

names(keyB) = str_replace(names(keyB), 
                           "(^)([0-9]{1}$)", 
                           "R_\\2") 

names(keyC) = str_replace(names(keyC), 
                           "(^)([0-9]{1}$)", 
                           "R_\\2") 
keyC = rename(keyC, X1 = .)
```

The `Key` column indicates the position of the correct response. We create a key vector that contains the value of the correct response, not the position.

```{r}

create_key = function(keydf){
  # select only response variables and concatonate by row into vectors
  keydf$response_vector = keydf %>%
    select(starts_with("R")) %>%
    pmap(~c(..1, ..2, ..3, ..4, ..5, ..6))

  # map across response vectors and key positions to pull out correct answer
  keydf = keydf %>%
    mutate(answer = map2_chr(response_vector, Key,
                         ~.x[.y]))
  return(keydf)
}

keyA = create_key(keyA) %>%
  mutate(form = "A")
keyB = create_key(keyB) %>%
  mutate(form = "B")
keyC = create_key(keyC) %>%
  group_by(Stimulus) %>%
  mutate(form = ifelse(row_number() == 1, "C", "D")) %>%
  ungroup()
```

Merge keys together.

```{r}
masterKey = keyA %>%
  full_join(keyB) %>%
  full_join(keyC) %>%
  select(X1:Key, answer, form) %>%
  rename(item = X1)
```


# Score data new

First, we merge all raw datasets.

```{r}
all_data = formA %>%
  full_join(formB) %>%
  full_join(formC)
```

```{r}
alldata_scored = score.multiple.choice(
  key = masterKey$Key, 
  data = all_data[, masterKey$item], 
  score = FALSE)
```

Remove items which were mistakes (see key_C, sheet entitled linking C to A and B.)

```{r, eval = T}
remove_items = c(
    "q_21148",
    "q_22573",
    "q_22496",
    "q_20052",
    "q_21409",
    "q_22068",
    "q_22169",
    "q_21911",
    "q_21185",
    "q_21288",
    "q_20790",
    "q_20033",
    "q_24285",
    "q_23402",
    "q_24824",
    "q_23044",
    "q_25399",
    "q_23847",
    "q_23990",
    "q_23485",
    "q_24709",
    "q_23602",
    "q_24676",
    "q_25281",
    "q_23456")

remove_which = which(masterKey$item %in% remove_items)

alldata_scored = alldata_scored[, -remove_which]
masterKey = filter(masterKey, !(item %in% remove_items))
all_data = select(all_data, -all_of(remove_items))
```

# Data for publication

## Demographics

```{r}
demo = all_data %>%
  mutate(comb_id = case_when(
    !is.na(prolificID) ~ prolificID,
    !is.na(mTurkCode) ~ as.character(mTurkCode),
    TRUE ~ NA_character_
  )) %>%
  mutate(row = row_number() + 1000) %>%
  group_by(comb_id) %>%
  mutate(row = min(row)) %>%
  mutate(PID = paste0("R", row)) %>%
  ungroup() %>%
  mutate(
    english_cat = case_when(
      english == 1 ~ "Very well (fluent/native)",
      english == 2 ~ "Well",
      english == 3 ~ "Not well",
      english == 4 ~ "Not at all (Need translation)",
      TRUE ~ NA_character_),
    growup_cat = case_when(
      growup == 1 ~ "United States of America",
      growup == 2 ~ "Outside of the US"),
    live_cat = case_when(
      live == 1 ~ "Yes",
      live == 2 ~ "No"),
    states = recode(states, 
                    !!!c(state.name[1:8], "District of Columbia", state.name[9:50])
                    ),
    sex = case_when(
      sex == 1 ~ "Male",
      sex == 2 ~ "Female",
      sex == 3 ~ "Other",
      sex == 4 ~ "Prefer not to say"),
    edu = case_when(
      edu == 0 ~ "Less than 12 years", 
      edu == 1 ~  "High school grad/GED",
      edu == 2 ~  "Currently in college/university",
      edu == 3 ~  "Some college/university, but did not graduate",
      edu == 4 ~  "Associate degree (2 yr)",
      edu == 5 ~  "College/university degree (4 yr)",
      edu == 6 ~  "Currently in grad/professional school",
      edu == 7 ~  "Grad/professional degree"),
    ethnic = case_when(
     ethnic == 1 ~ "American Indian/Alaskan Native",
     ethnic == 2 ~ "Asian",
     ethnic == 3 ~ "Black",
     ethnic == 4 ~ "Hispanic",
     ethnic == 5 ~ "White",
     ethnic == 6 ~ "Mixed (two or more)",
     ethnic == 7 ~ "Other"),
    hhinc = case_when(
      hhinc == 1 ~ "< 20K",
      hhinc == 2 ~ "20K-40K",
      hhinc == 3 ~ "40K-60K",
      hhinc == 4 ~ "60K-80K",
      hhinc == 5 ~ "80K-100K",
      hhinc == 6 ~ "100K-120K",
      hhinc == 7 ~ "120K-150K",
      hhinc == 8 ~ "150K-200K",
      hhinc == 9 ~ "200K-250K",
      hhinc == 10 ~ "250K-350K",
      hhinc == 11 ~ "350K-500K",
      hhinc == 12 ~ "> 500K",
      hhinc == 13 ~ "Prefer not to say"))
```

Participants are excluded from analyses if they
* complete the survey in less than 3 minutes (180 seconds),
* don't speak fluent English,
* grew up outside the US, or
* are currently living outside the US.

```{r}
demo = demo %>%
  mutate(included = case_when(
    `Duration (in seconds)` < 180 ~ "No",
    english > 2 ~ "No",
    growup == 2 ~ "No",
    live == 2 ~ "No",
    TRUE ~ "Yes"
  ))
```

163 rows are excluded on this basis.

```{r}
demo = demo %>%
  select(PID, StartDate, `Duration (in seconds)`, english_cat, growup_cat, live_cat, states, age, sex, edu, ethnic, hhinc, included)

names(demo) = str_remove(names(demo), "_cat")
```


## Correct or incorrect

```{r}
alldata_scored_df = as.data.frame(alldata_scored)
data_scored = cbind(demo, alldata_scored)
write_csv(data_scored, 
          file = here("data/TDA_data_scored.csv"))
```

## Response option

First we create a vector for each item that specifies the new labels. All distractors take the form `R1` through `R5`. `Ans` (for the correct answer) is then inserted in the location of the correct response.

```{r}


masterKey = masterKey %>%
  mutate(relevel = map(Key, 
                       ~insert(c("R1","R2","R3","R4","R5","I don't know", "None of these"), 
                              at = .x, "Ans")))
```

Next we create a function that takes a vector of responses and the name of the item. The item name is used to identify the correct vector created in the previous code chunk. This is applied using the recode function and the new vector is returned. 

```{r}
relevel_fun = function(response, item_name){
  relevel_vector = masterKey$relevel[masterKey$item == item_name][[1]]
  new_vector = recode(response, !!!relevel_vector)
  return(new_vector)
}
```

We select just the TDA items and assign each row a unique number. This will help ensure all the responses end up in the correct place when we spread later. Then we stack questions and nest, to create a separate data frame for each item, containing a column called "response."

```{r}
raw_items = all_data %>%
  select(starts_with("q_")) %>%
  mutate(row = row_number()) %>%
  gather("item", "response", starts_with("q_")) %>%
  group_by(item) %>%
  nest()

# what does this look like
head(raw_items)
head(raw_items$data[[1]]) 
table(raw_items$data[[1]]$response) 
```

Iterating across items, we apply the `relevel` function to the dataset, which replaces numeric values with the appropriate categorical value (Ans, R1:R5, I don't know, and None of these)

```{r}
recoded_items = raw_items %>%
  mutate(data = map2(data, item, 
                     ~mutate(.x, response = relevel_fun(response, .y)))) 

# what does this look like
head(recoded_items$data[[1]]) 
table(recoded_items$data[[1]]$response) 
```

We unnest the data frames and spread back into the original format, ending with arrange to ensure the data are in the same rows as before.
```{r}
recoded_items = recoded_items %>% 
  unnest(cols = c(data)) %>%
  spread(item, response) %>% 
  arrange(row) %>% 
  select(-row)
```

Finally, we connect these responses to the demographic variables and save. 

```{r}
data_recode = cbind(demo, recoded_items)
write_csv(data_recode, 
          file = here("data/TDA_data_recoded.csv"))
```

We also save a shortened version of the master key object.

```{r}
masterKey %>%
  select(item, answer, form) %>%
  write_csv(file = here("data/masterkey.csv"))
```




