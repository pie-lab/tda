---
title: "Cleaning and summarizing"
date: "Last updated `r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
---

```{r, include = F}
knitr::opts_chunk$set(message = F, warning = F)
```


# Load data and packages

```{r, message = F, warning = F}
library(here) # for engaging with working environment
library(rio) # for importing excel files
library(tidyverse) # for data cleaning and manipulation
library(psych) # for scoring multiple choice items
library(DT) # for viewing data tables
```

## Qualtrics survey responses

The excel files contain raw data exported from Qualtrics. The first row of this file contains variable names, but rows 2 and 3 contain meta data. To account, we first load in all data as a "names" data frame and then data starting at row 4, for the raw data. 

```{r, message = F, warning = F}
# read in form A (Prolific)
formA_names = read_csv(
  here("data/Form+A_Prolific_April+2,+2021_15.27.csv"))

formA = read_csv(
  here("data/Form+A_Prolific_April+2,+2021_15.27.csv"), 
  col_names = F, skip = 3)

names(formA) = names(formA_names)
rm(formA_names)

# read in form A (MTurk)
formA_names = read_csv(
  here("data/Form A_April 2, 2021_15.41.numeric.csv"))

formA2 = read_csv(
  here("data/Form A_April 2, 2021_15.41.numeric.csv"), 
  col_names = F, skip = 3)

names(formA2) = names(formA_names)
rm(formA_names)

formA = full_join(formA, formA2)
rm(formA2)

# read in form B (Prolific)
formB_names = read_csv(
  here("data/Form+B_Prolific_April+2,+2021_15.27.csv"))

formB = read_csv(
  here("data/Form+B_Prolific_April+2,+2021_15.27.csv"), 
  col_names = F, skip = 3)

names(formB) = names(formB_names)
rm(formB_names)


# read in form B (MTurk)
formB_names = read_csv(
  here("data/Form B_April 2, 2021_15.44.numeric.csv"))

formB2 = read_csv(
  here("data/Form B_April 2, 2021_15.44.numeric.csv"), 
  col_names = F, skip = 3)

names(formB2) = names(formB_names)
rm(formB_names)

formB = full_join(formB, formB2)
rm(formB2)

# read in form C (Prolific)
formC_names = read_csv(
  here("data/Form+C_April+16,+2021_17.21.csv"))

formC = read_csv(
  here("data/Form+C_April+16,+2021_17.21.csv"), 
  col_names = F, skip = 3)

names(formC) = names(formC_names)
rm(formC_names)
```

In forms A and B, variable names composed solely of numbers (e.g., 20001) refer to the specific variable number as included in the dictionary. These must be prefaced by `q_` for readability. 

```{r}
names(formA) = str_replace(names(formA), # look in this vector of strings
                           "(^)([0-9]*$)", #match two parts. part 1: beginning of string, second part: digits 0 or more times and then the string ends
                           "q_\\2") # replace with q_ followed by the second part of the match

names(formB) = str_replace(names(formB), 
                           "(^)([0-9]*$)", 
                           "q_\\2") 

names(formC) = str_replace(names(formC), 
                           "^Q", 
                           "q_") 
```

## Filter participants

Remove participants without valid Prolific or MTurk IDs.

```{r}
formA = formA %>%
  filter(!is.na(mTurkCode) | str_length(PROLIFIC_PID) > 3)
formB = formB %>%
  filter(!is.na(mTurkCode) | str_length(PROLIFIC_PID) > 3)
formC = formC %>%
  filter(str_length(PROLIFIC_PID) > 3)
```

Remove participants who don't speak English fluently.

```{r}
formA = filter(formA, english < 3)

formB = filter(formB, english < 3)

formC = filter(formC, english < 3)
```

Remove participants who grew up outside the US.

```{r}
formA = filter(formA, growup == 1 )
formB = filter(formB, growup == 1 )
formC = filter(formC, growup == 1 )
```

Remove participants currently living outside the US.

```{r}
formA = filter(formA, live == 1 )
formB = filter(formB, live == 1 )
formC = filter(formC, live == 1 )
```


## Scoring keys

```{r, message = F, warning = F}
keyA = read_csv(here("keys/key_A.csv"))
keyB = read_csv(here("keys/key_B.csv"))
keyC = import(here("keys/key_C.xlsx"), sheet = 1)
```

Variable names composed solely of numbers (e.g., 1) refer to the response choice number as presented to participants. These must be prefaced by `R_` for readability. 

```{r}
names(keyA) = str_replace(names(keyA), 
                           "(^)([0-9]{1}$)", 
                           "R_\\2") 

names(keyB) = str_replace(names(keyB), 
                           "(^)([0-9]{1}$)", 
                           "R_\\2") 

names(keyC) = str_replace(names(keyC), 
                           "(^)([0-9]{1}$)", 
                           "R_\\2") 
keyC = rename(keyC, X1 = .)
```

The `Key` column indicates the position of the correct response. We create a key vector that contains the value of the correct response, not the position.

```{r}

create_key = function(keydf){
  # select only response variables and concatonate by row into vectors
  keydf$response_vector = keydf %>%
    select(starts_with("R")) %>%
    pmap(~c(..1, ..2, ..3, ..4, ..5, ..6))

  # map across response vectors and key positions to pull out correct answer
  keydf = keydf %>%
    mutate(answer = map2_chr(response_vector, Key,
                         ~.x[.y]))
  return(keydf)
}

keyA = create_key(keyA) %>%
  mutate(form = "A")
keyB = create_key(keyB) %>%
  mutate(form = "B")
keyC = create_key(keyC) %>%
  group_by(Stimulus) %>%
  mutate(form = ifelse(row_number() == 1, "C", "D")) %>%
  ungroup()
```

Merge keys together.

```{r}
masterKey = keyA %>%
  full_join(keyB) %>%
  full_join(keyC) %>%
  select(X1:Key, answer, form) %>%
  rename(item = X1)
```


# Score data new

First, we merge all raw datasets.

```{r}
all_data = formA %>%
  full_join(formB) %>%
  full_join(formC)
```

```{r}
alldata_scored = score.multiple.choice(
  key = masterKey$Key, 
  data = all_data[, masterKey$item], 
  score = FALSE)
```

Remove items which were mistakes (see key_C, sheet entitled linking C to A and B.)

```{r, eval = T}
remove_items = c(
    "q_21148",
    "q_22573",
    "q_22496",
    "q_20052",
    "q_21409",
    "q_22068",
    "q_22169",
    "q_21911",
    "q_21185",
    "q_21288",
    "q_20790",
    "q_20033",
    "q_24285",
    "q_23402",
    "q_24824",
    "q_23044",
    "q_25399",
    "q_23847",
    "q_23990",
    "q_23485",
    "q_24709",
    "q_23602",
    "q_24676",
    "q_25281",
    "q_23456")

remove_which = which(masterKey$item %in% remove_items)

alldata_scored = alldata_scored[, -remove_which]
masterKey = filter(masterKey, !(item %in% remove_items))
all_data = select(all_data, -all_of(remove_items))
```

# Calculate item means

```{r, results = 'asis'}
alldata_means = colMeans(alldata_scored, na.rm = T)

all_item_means = data.frame(
  item = masterKey$item,
  prop_correct = alldata_means
)

item_prop = masterKey %>%
  select(item, answer, Stimulus:R_6, form) %>%
  full_join(all_item_means) %>%
  mutate(prop_correct = round(prop_correct, 2)) 

# number of administrations
count_valid = function(x){
  n = length(which(!is.na(x)))
  return(n)
}

```

Count number of assessments for each item.

```{r}
item_prop$N = apply(alldata_scored, 2, count_valid)
```

# Distractor index

```{r}
distract = all_data %>%
  select(starts_with("q_")) %>%
  gather("item", "response") %>%
  filter(!is.na(response)) %>%
  full_join(select(masterKey, item, Key))

distract = distract %>%
  mutate(response = ifelse(response == Key, NA, response))

distract = distract %>%
  group_by(item, response) %>%
  count() %>%
  group_by(item) %>%
  mutate(total_n = sum(n)) %>%
  filter(!is.na(response)) %>%
  mutate(wrong_n = sum(n),
         prop_total = n/total_n,
         prop_wrong = n/wrong_n) %>%
  filter(response < 7) %>%
  summarise(prop_total = max(prop_total),
            prop_wrong = max(prop_wrong),
            n_wrong = max(wrong_n)) 

item_prop = item_prop %>%
  full_join(distract) 

item_prop = item_prop %>%
  mutate(across(where(is.double), round, 2)) 


save(item_prop, file = here("data/item_prop.Rdata"))
```




